## 응답시간

-   TTFB : 요청을 하고 응답의 첫 번째 바이트가 도착하기까지 걸린 시간
    -   DNS 검색, TCP Handshake, SSL handhshake(HTTPS) …
    -   병목 탐지에 도움이 될 수 있다. → 느리면 보통 서버 처리나 네트워크가 느림
-   TTLB : 요청을 하고 마지막 바이트가 도착하기까지 걸린 시간

## 처리량

-   RPS (Requests Per Second)
    -   보통 HTTP 요청 같은 것 카운트
-   TPS (Transactions Per Second)
    -   DB 관점에서의 단위
    -   비지니스 관점에서의 단위 (주문 1건, 결제 1건 등)

요청 1개가 여러개의 DB 트랜잭션 만들 수도 있고, 여러 요청을 모아서 트랜잭션 1개로 처리할 수도 있음

⇒ 무엇을 한 건으로 할 건지 정확히 정의해야 유의미한 지표가 나옴

## 수직 확장 (scale-up)과 수평 확장 (scale-out)

가상 면접 사례로 배우는 대규모 시스템 설계 기초 1권의 1, 2장을 참고하면 좋음

**로드밸런서** — 들어오는 트래픽을 여러 서버로 분산해서 한 서버에 트래픽이 몰리지 않도록 함

-   L2 (Data Link)
    -   MAC
-   L3 (Network)
    -   IP
-   L4 (Transport)
    -   IP + 포트 + 프로토콜(TCP/UDP)
-   L7 (Application)
    -   HTTP 요청 내용을 보고 라우팅 가능
    -   요청 내용을 뜯어봐야 해서 L4보다 속도가 느릴 수 있음

## DB 커넥션 풀

보통 원격 RDB와의 커넥션은 TCP 기반. 즉, open시에 3-way handshake하고 close시에 4-way handshake

따라서 매 요청마다 `Connection`을 새로 만들면 비용이 비싸므로 미리 커넥션을 만들어 놓고 풀에 보관함.

-   커넥션을 재사용하여 비용/지연을 줄임
-   DB에 대한 커넥션 수를 제한

### HikariCP

오픈소스 JDBC 커넥션 풀 라이브러리. Spring Boot 기본 커넥션 풀

[https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP)

README에서 Frequently used는 알아두는게 좋음

-   풀 사이즈
    -   `minimumIdle` : 최소 idle 커넥션 유지 개수 (디폴트 -maximumPoolSize)
    -   `maximumPoolSize` : 최대 커넥션 수 (디폴트 - 10)
-   타임아웃
    -   `connectionTimeout` : 커넥션 빌리려고 기다리는 최대 시간. 초과하면 SQLException (디폴트 - 30초. 최소 시간 250ms)
    -   `idleTimeout` : 커넥션이 풀에서 유휴(idle) 상태로 머물 수 있는 최대 시간. `mimimumIdle` < `maximumPoolSize` 일 때만 적용됨. (디폴트 - 10분, 최소 10초, 0이면 제거 X)
-   시간
    -   `keepaliveTime` : DB나 네트워크 인프라가 커넥션을 타임아웃으로 끊는 것을 방지하기 위해, HikariCP가 얼마나 자주 살아있게 유지하려 시도할지 제어하는 값. `maxLifetime`보다 작아야 함. keepalive 시점이 되면 해당 커넥션을 풀에서 잠시 빌려서 ping을 날리고 다시 풀로 반환함. (기본 2분, 최소 30초)
    -   `maxLifetime` : 이 값을 설정하는 것을 강하게 권장하며, DB나 인프라가 강제하는 커넥션 시간 제한보다 몇 초 짧게 설정해야 한다. “대량 소멸(mass-extinction)”을 피하기 위해, 커넥션별로 약간의 음수 감쇠(조금 더 일찍 만료되도록 하는 랜덤성)가 적용됨. (디폴트 - 30분, 최소 30초)
        -   오래된 커넥션을 끊고 새로 만들기 위함

## 캐시

-   로컬 캐시 — 서버 프로세스 안에 있는 캐시
    -   장점
        -   Low latency (네트워크 왕복 X)
        -   구현 단순
    -   단점
        -   휘발성
        -   서버가 여러 대인 경우
-   리모트 캐시 — 별도 캐시 서버/클러스터에 있는 캐시. 네트워크로 접근
    -   여러 서버가 하나의 캐시 공유
    -   네트워크 지연 발생
    -   운영 비용/복잡도 증가
-   실제 운영에선 로컬 캐시 + 리모트 캐시 + DB로 많이 사용

(+ 브라우저 캐시, CDN/엣지 캐시)

용어

-   cache hit
-   cache miss
-   proactive caching
-   reactive caching
-   cache invalidation
    -   stale

### 캐시 워밍

트래픽이 오기 전에 미리 캐시에 데이터를 적재하여 초기 미스(cache cold)를 줄이는 전략

-   주요 데이터 미리 적재
-   스케줄 기반 워밍

**캐시 프리패칭** : 사용자 행동 흐름을 기반으로 “다음에 필요할 것”을 선제적으로 가져옴

-   예) 길찾기

### 캐시 전략

-   읽기 전략
    -   Cache-Aside (Look-Aside, Lazy loading) — 애플리케이션이
    -   Read-Through — 캐시 계층이. 앱은 캐시만 호출
-   캐시 미스 났을 때 누가 DB를 읽고 채우는지에 따라
-   쓰기 전략
    -   Write-Through : 쓰기 요청 시 캐시와 DB에 동시에 데이터를 저장
    -   Write-Behind (Write-Back) : 쓰기 요청 시 캐시에 먼저 쓰고, DB에는 비동기로 반영
    -   Write-Around : 캐시엔 쓰지 않고 DB에만 반영. 캐시는 읽을 때 채워짐

### 이슈

-   캐시 스탬피드 — TTL이 동시에 만료되면 모두 DB로 몰림
    -   TTL에 Jitter(랜덤) 추가
    -   Single Flight : 동일한 작업이 동시에 요청될 때 중복 실행 방지 (첫 번째 요청만 실제로 수행하고 나머지는 결과 공유)
-   캐시 오염 — 자주 사용하지 않거나 앞으로 사용할 가능성이 낮은 데이터가 저장되어 중요한 데이터나 자주 사용하는 데이터(핫 데이터)가 캐시에서 밀려나게 되는 상황

[캐시 문제 해결 가이드 - DB 과부하 방지 실전 팁](https://toss.tech/article/25301)

[SDUI의 성능 병목을 넘어: 올리브영 로컬 캐시 기반 백엔드 최적화 성공기 | 올리브영 테크블로그](https://oliveyoung.tech/2025-11-11/sdui_with_caffein/)

### 캐시 무효화

원본 값이 바뀌었을 때, 캐시에 남아있는 예전 값을 언제/어떻게 제거할지 갱신할지 설계

-   TTL
-   Delete — 쓰기 시 캐시 삭제
-   Update — 쓰기 시 캐시 갱신 (dual-write)

**문제 상황**

1.  삭제-리필 경쟁(race)으로 옛값이 다시 캐시에 들어가는 문제
    -   T1: 어떤 요청이 캐시 MISS → DB에서 “옛값” 읽는 중
    -   T2: 다른 요청이 DB UPDATE 후 캐시 DEL
    -   T1이 조금 늦게 DB 응답 받아서 캐시에 SET 해버리면 삭제했는데도 옛값이 다시 저장됨해결 방법:
    -   결과: 최신 값으로 저장되지 않고 옛날 값으로 오염됨
    -   버전/타임스탬프 추가
    -   Write로만 캐시 갱신 (별로인 듯)
2.  상황:
3.  여러 키가 엮인 데이터(리스트/인덱스/검색 결과)예) `user:123` 하나 바뀌면 `userList:page1`, `topUsers`같은 파생 캐시가 다 영향을 받음
    -   정규화/역참조 키 : 이 엔티티가 포함된 캐시 키 목록을 따로 관리해서 무효화 범위를 찾기
    -   generation key : `user:123:gen` 값을 올리고, 실제 캐시 키를 `user:123:v{gen}` 형태로 만들어서 세대가 바뀌면 자연스럽게 미스가 나게 함
4.  해결 방법:
5.  상황: 하나가 바뀌어서 파생 캐시가 영향을 받는 경우

## 가비지 컬렉터

[Java Garbage Collection - NAVER D2](https://d2.naver.com/helloworld/1329)

### 참조 카운팅 (Reference Counting)

-   아이디어 : 객체가 몇 군데에서 참조되고 있는지 카운트를 세고 있다가, 0이 되면 즉시 해제.
-   장점 : 구현이 간단하고, 빠르다
-   용어
    -   강한 참조 (Strong ref.) — 객체를 “소유/보유”하는 참조. `refCount`에 반영 O
    -   약한 참조 (Weak ref.) — 객체를 “그냥 바라보기만” 하는 참조. `refCount`에 반영 X
    -   예) Parent -> Child (strong), Child -> Parent (strong)
-   문제점
    -   Circular Referencing (순환 참조) → 쓰이지 않는데 서로 참조하면서 메모리 누수 발생 가능성
        -   해결 방법
            1.  약한 참조 사용
            2.  순환 검출 (Cycle detection) → 외부에서 도달 불가능한 컴포넌트를 찾아 정리
            3.  예) 파이썬 Cyclic Garbage Collector
    -   참조 바뀔 때마다 증감이 바뀌므로 오버헤드가 있을 수 있음

### 마크-스윕 (Mark and Sweep)

루트에서 도달 가능한 객체만 살아있다고 보고 나머지는 회수하는 대표적인 Tracing GC

-   아이디어 :
    -   Mark stage — GC Roots(스택 지역변수, 전역/정적 변수, 레지스터, JNI 등)에서 포인터를 따라가며 도달 가능한 객체를 마킹
    -   Sweep stage — 마킹이 안 된 객체를 해제(혹은 free list에 넣음)
-   문제점
    -   Stop-the-world
    -   Fragmentation

(+ tri-color marking)

### Mark-Compact

Mark–Sweep에 살아있는 객체를 한쪽으로 몰아 단편화를 없애는 단계(compact)를 붙인 GC

**comapction algorithm**

-   Table-based
-   LISP2
-   The Compressor

### Generational GC

-   **Weak Generational hypothesis**
    -   대부분의 객체는 금방 unreachable 상태가 된다.
    -   오래된(Old) 객체에서 신생(Young) 객체로의 참조는 매우 드물다.

위 가설에 따라 Heap 영역을 세대로 나눠 자주 죽는 객체는 자주 그리고 싸게 치우고, 오래 사는 객체는 가끔 정리하는 방식의 GC (일종의 휴리스틱)

-   Java HotSpot VM에서는  
    [##_Image|kage@df0qLc/dJMcajtXNyq/AAAAAAAAAAAAAAAAAAAAAOAwiitQr2pk0URAZY2P63rF7gWNS0UiLvvwdkTeQhvj/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=cNpf9hAqJEb2qxYWkAJcfLkfzs8%3D|CDM|1.3|{"originWidth":713,"originHeight":222,"style":"alignCenter","width":530,"height":165}_##]
    -   **Young generation** — Minor GC
        -   **Eden** : 새로 생성된 객체가 할당되는 영역
        -   **Survivor 공간 2개 (S0, S1)** : Minor GC에서 1번 이상 살아남은 객체가 존재하는 영역. Minor GC가 수행되고 나면 두 공간 중 하나는 무조건 비어있게됨.
        -   Eden + S0을 GC 돌려서 살아남은 객체를 S1에 복사
        -   Eden + S1을 GC 돌려서 살아남은 객체를 S0에 복사
        -   객체에 `age`와 같은 정보가 있음. `age`가 임계치(tenuring threshold)를 넘으면 Old로 승격됨(promotion)
    -   **Old generation** — Major/Full GC
    -   Permanent generation (Java 8부터 제거됨)

## 응답 데이터 압축

응답 데이터를 압축해 데이터 전송량을 줄인다. → 응답 시간, 비용 절약

-   Accept-Encoding
-   Content-Encoding

## 대기 처리

동시 처리(Active) 수를 강제로 제한하고, 초과 요청은 즉시 거절하거나 대기열(Queue)로 보내서 순서대로 입장시키는 식으로 구현

⇒ `Queue` + `Token` 으로 구현 많이함

(+ 추가로 공부해야 할 것 : JVM)

---

## 스터디원과의 소통/공유

-   모니터링 툴 : Pinpoint [대규모 분산 시스템 추적 플랫폼 - NAVER D2](https://d2.naver.com/helloworld/1194202)
-   CPU 코어 증가가 최대 TPS를 늘릴 수 있는 이유? ⇒ CPU Bound가 많은 경우, 동시에 실제로 실행될 수 있는 CPU 시간이 늘어남.
-   Redis에도 문자열 같은거 압축해서 저장하는 방법 - gzip이나 zstd로 압축
-   [R2DBC Connection Pool 실종 사건 - 카카오페이](https://tech.kakaopay.com/post/r2dbc-connection-pool-missing/)
